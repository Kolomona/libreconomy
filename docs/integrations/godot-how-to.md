# Integrating `libreconomy` into a Godot Project (Godot 4 GDExtension Focus)

This guide shows how to consume the Rust `libreconomy` simulation library inside a Godot game (Godot 4 recommended). It uses a thin C++ GDExtension bridge that forwards calls into the exported Rust C ABI produced by `cbindgen` + Uniffi.

> If you're still on Godot 3, see the legacy GDNative appendix at the end. Prefer upgrading—GDExtension removes the recompilation friction present in GDNative.

## 1. Overview
`libreconomy` is compiled as a native shared library (`liblibreconomy.so` on Linux) with accompanying headers and optional language bindings. For Godot integration you only need:

- The shared library (`liblibreconomy.so` or platform equivalent)
- The C header (`libreconomy.h`) generated via `cbindgen`
- (Optional) Uniffi-generated language bindings if you embed scripting languages other than GDScript (not needed for core integration)

Rather than calling the Rust library directly from GDScript, we create a small C++ GDExtension that wraps exported functions and exposes a high-level `LibreEconomy` class to Godot.

## 2. One-command bundle: `dist/godot4/`
Run the release script to build Rust, docs, and a Godot 4 integration bundle.

```bash
bash scripts/release.sh
```

After it finishes, check `dist/godot4/`:

- `lib/` — Rust shared library (`liblibreconomy.*`) and header (`libreconomy.h`)
- `bridge/` — C++ GDExtension sources: `libreconomy_bridge.cpp`, `libreconomy.gdextension`, `SConstruct`
- `build/` — output location where the bridge (.so) will be produced if you build it
- `README.md` — quick steps to build and drop into your Godot project

If you set `GODOT_CPP_DIR` and have SCons installed, the script can optionally auto-build the bridge. Otherwise, you can build it yourself using the scaffold in `bridge/`.

## 3. Godot Project Layout (Suggested)
```
my_godot_game/
  addons/ (if needed)
  native/
    libreconomy/
      liblibreconomy.so          # Rust shared library
      libreconomy.h              # C header
    libreeconomy_gdextension.so# Built bridge from dist/godot4/build/
    liblibreconomy.so          # From dist/godot4/lib/
    libreconomy.h              # From dist/godot4/lib/
    libreconomy.gdextension    # From dist/godot4/bridge/
  scripts/
    test_libreconomy.gd
  project.godot
```

## 4. Prereq: godot-cpp for Godot 4.5.1 (Linux x86_64)
Build or fetch `godot-cpp` matching Godot v4.5.1. Set an environment variable pointing to it:

```bash
export GODOT_CPP_DIR=/path/to/godot-cpp-4.5.1-linux-x86_64
```

It must contain `include/` and `bin/` with the compiled `libgodot-cpp`.

## 5. C++ Bridge Implementation
Create `libreconomy_bridge.cpp`:

```cpp
// libreconomy_bridge.cpp
#include <godot_cpp/classes/ref_counted.hpp>
#include <godot_cpp/core/class_db.hpp>
#include <godot_cpp/gdextension_interface.h>
#include "libreconomy.h" // Generated by cbindgen

using namespace godot;

class LibreEconomy : public RefCounted {
    GDCLASS(LibreEconomy, RefCounted);
protected:
    static void _bind_methods() {
        ClassDB::bind_method(D_METHOD("version"), &LibreEconomy::version);
        ClassDB::bind_method(D_METHOD("agent_count"), &LibreEconomy::agent_count);
        // Future: add bind_method calls for create_agent, remove_agent, query components, etc.
    }
public:
    String version() const {
        const char *v = libreconomy_version(); // Example exported Rust fn; ensure it's in header
        return String(v);
    }
    int64_t agent_count() const {
        return (int64_t)get_agent_count(); // Replace with actual exported count function
    }
};

extern "C" GD_EXTENSION_API GDExtensionBool
libreconomy_library_init(const GDExtensionInterface *p_interface,
                         GDExtensionClassLibraryPtr p_library,
                         GDExtensionInitialization *r_initialization) {
    GDExtensionBinding::InitObject init_obj(p_interface, p_library, r_initialization);
    init_obj.register_initializer([]() { ClassDB::register_class<LibreEconomy>(); });
    init_obj.set_minimum_library_initialization_level(MODULE_INITIALIZATION_LEVEL_SCENE);
    return init_obj.init();
}
```

Adjust function names (`libreconomy_version`, `get_agent_count`) to actual exported symbols. Consult `libreconomy.h` to confirm.

## 6. GDExtension Configuration File
Create `libreconomy.gdextension`:

```ini
[configuration]
entry_symbol = "libreconomy_library_init"
compatibility_minimum = 4.0

[libraries]
linux.debug.x86_64 = "res://native/libreconomy/libreconomy_gdextension.so"
linux.release.x86_64 = "res://native/libreconomy/libreconomy_gdextension.so"
# Add macOS / Windows variants after building:
# macos.release.arm64 = "res://native/libreconomy/libreconomy_gdextension.dylib"
# windows.release.x86_64 = "res://native/libreconomy/libreconomy_gdextension.dll"
```

## 7. Build the bridge (SCons)
From `dist/godot4/`, build the bridge using SCons and the scaffold:

```python
# In shell:
# 1) export GODOT_CPP_DIR=/path/to/godot-cpp-4.5.1-linux-x86_64
# 2) scons -C dist/godot4/bridge
# Output: dist/godot4/build/libreconomy_gdextension.so
```

Platform adjustments:
- Windows: produce `.dll` and ensure `liblibreconomy.dll` is discoverable (same folder or PATH).
- macOS: produce `.dylib`; may need `install_name_tool` changes for runtime path.

## 8. Runtime Library Placement
Copy these into your project under `res://native/libreconomy/`:
- `dist/godot4/build/libreconomy_gdextension.so` (the bridge)
- `dist/godot4/lib/liblibreconomy.so` (Rust library)
- `dist/godot4/bridge/libreconomy.gdextension` (config)

## 9. Using the Extension from GDScript

The bridge exposes a `LibreWorld` class that manages the entire ECS world and provides agent management.

Example script `scripts/test_libreconomy.gd`:

```gdscript
extends Node

var world: LibreWorld

func _ready():
    # Create a new simulation world
    world = LibreWorld.new()
    print("LibreEconomy version: %s" % world.get_version())
    
    # Create agents with different configurations
    var agent1 = world.create_agent()  # Default: thirst=50, hunger=50, currency=100
    var agent2 = world.create_agent_with_needs(90.0, 40.0)  # Very thirsty agent
    var agent3 = world.create_agent_with_wallet(1000.0)  # Wealthy agent
    var agent4 = world.create_agent_full(75.0, 25.0, 500.0)  # Fully custom
    
    print("Created %d agents" % world.get_agent_count())
    print("Agent IDs: %d, %d, %d, %d" % [agent1, agent2, agent3, agent4])
    
    # Remove an agent
    if world.remove_agent(agent2):
        print("Removed agent %d" % agent2)
    
    print("Remaining agents: %d" % world.get_agent_count())

func _exit_tree():
    # World is automatically cleaned up when LibreWorld is freed
    world = null
```

Attach to a scene, run, and inspect the console output.

### Available Methods

- `get_version()` → String - Library version
- `create_agent()` → int - Create agent with defaults (thirst=50, hunger=50, currency=100)
- `create_agent_with_needs(thirst: float, hunger: float)` → int - Custom needs
- `create_agent_with_wallet(currency: float)` → int - Custom starting currency
- `create_agent_full(thirst: float, hunger: float, currency: float)` → int - All custom parameters
- `remove_agent(entity_id: int)` → bool - Remove agent, returns true on success
- `get_agent_count()` → int - Total number of agents in the world

## 10. Extending the API

The current bridge provides basic agent lifecycle management. To expose more functionality:

### Add to Rust FFI (`src/ffi/mod.rs`)
1. Export new functions with `#[no_mangle] pub extern "C"`
2. Use `WorldHandle` pointer and simple C types (numbers, strings as `*const c_char`)
3. Rebuild to regenerate `libreconomy.h` via cbindgen

### Update Bridge (`dist/godot4/bridge/libreconomy_bridge.cpp`)
1. Add new methods to `LibreWorld` class
2. Call the C functions using `::function_name(world_ptr, ...)`
3. Bind with `ClassDB::bind_method` in `_bind_methods()`
4. Marshal Godot types: `String` ↔ char*, `Array` ↔ arrays, etc.

### Rebuild
```bash
bash scripts/release.sh
```

The script regenerates the header, updates the bridge template, and recompiles automatically if `GODOT_CPP_DIR` is set.

## 11. Development Workflow

### Adding New Features
1. Implement in Rust (`src/agent/`, `src/ffi/mod.rs`)
2. Run `bash scripts/release.sh` (rebuilds lib, regenerates header, updates bridge, compiles)
3. Copy updated `.so` files to your Godot project
4. Restart Godot editor to reload symbols

### Hot Reload Notes
- Godot may cache GDExtension symbols; restart the editor after updating the bridge
- If you only change Rust logic (not FFI signatures), just replace `liblibreconomy.so`
- If you change C function signatures, the full rebuild is necessary

## 12. Versioning & Stability
Track a Rust-side semantic version and expose it via a function like `libreconomy_version()`. Increment when the C ABI changes. Godot scripts can assert compatibility.

## 13. Platform Notes
| Platform | Notes |
|----------|-------|
| Linux | Keep both .so files in same directory. RPATH generally okay inside Godot. |
| Windows | Ensure `liblibreconomy.dll` is next to `libreconomy_gdextension.dll`; name may need `lib` prefix removal depending on build tools. |
| macOS | Use `.dylib`; may need `install_name_tool -id @rpath/libreconomy.dylib` for relocation. |

## 14. Performance Considerations
- Batch operations: Prefer exposing Rust functions that operate on multiple agents/components at once vs. looping in GDScript.
- Avoid excessive string conversions—use numeric IDs or handles.
- If simulation ticks are heavy, expose a `step_simulation(delta_ms)` function in Rust.

## 15. Debugging Tips
- If Godot fails to load the extension, check the editor log for missing symbols.
- Use `ldd libreconomy_gdextension.so` (Linux) to verify `liblibreconomy.so` resolution.
- If version mismatch, rebuild godot-cpp for your exact engine version.

## 16. Optional: Uniffi Bindings Inside Godot
If embedding Python, Kotlin, or Swift (e.g., via custom modules), you can also use the Uniffi-generated bindings in `dist/`. This is atypical for standard GDScript workflows and generally unnecessary.

## 17. Legacy Godot 3 (GDNative) Appendix (Brief)
1. Produce `liblibreconomy.so` & header.
2. Write a C wrapper exposing Godot 3 style entry points (`godot_gdnative_init`, etc.).
3. Create `.gdnlib` referencing the library.
4. Bind methods similarly via `godot_method_bind`. (Higher maintenance — upgrade recommended.)

## 18. Next Steps / Enhancements
- Add automated build pipeline that runs `scripts/release.sh` and then rebuilds the GDExtension.
- Implement richer API: agent creation/removal, component queries, simulation stepping.
- Add integration tests using headless Godot (`--headless --quit` scripts) calling the extension.

## 19. Checklist
- [ ] Rust artifacts built (`dist/liblibreconomy.so`, `dist/libreconomy.h`)
- [ ] C++ bridge compiles
- [ ] `.gdextension` file points to built bridge
- [ ] Shared libraries placed in `res://native/libreconomy/`
- [ ] Basic GDScript call returns version & agent count
- [ ] Extended methods (optional) implemented & documented

---
**Maintenance Reminder:** Re-run `scripts/release.sh` whenever public Rust API changes, then rebuild the GDExtension to keep headers and symbols in sync.



---
Step-by-Step Integration
1. Build the Library and Bridge
First, make sure everything is built:

```
cd /home/hapa/k/code/ai/Vibe/libreconomy/libreconomy
bash scripts/release.sh
```

This should output:

liblibreconomy.so - The Rust library
libreconomy_gdextension.so - The Godot bridge
libreconomy.gdextension - The GDExtension config
2. Set Up Your Godot Project Structure
In your Godot project, create this folder structure:

```
cd /path/to/your/godot/project
mkdir -p addons/libreconomy
```

3. Copy the Files
Copy the three required files:

```
# Copy the Rust library
cp /home/hapa/k/code/ai/Vibe/libreconomy/libreconomy/dist/godot4/lib/liblibreconomy.so \
   addons/libreconomy/

# Copy the Godot bridge
cp /home/hapa/k/code/ai/Vibe/libreconomy/libreconomy/dist/godot4/build/libreconomy_gdextension.so \
   addons/libreconomy/

# Copy the GDExtension config
cp /home/hapa/k/code/ai/Vibe/libreconomy/libreconomy/dist/godot4/bridge/libreconomy.gdextension \
   addons/libreconomy/
```


4. Verify the .gdextension File
Open addons/libreconomy/libreconomy.gdextension and make sure the paths are correct:

```
[configuration]
entry_symbol = "libreconomy_library_init"

[libraries]
linux.debug.x86_64 = "res://addons/libreconomy/libreconomy_gdextension.so"
linux.release.x86_64 = "res://addons/libreconomy/libreconomy_gdextension.so"
```

5. Restart Godot
Close and reopen your Godot project. Godot should automatically detect the GDExtension.

6. Create a Test Script
In Godot, create a new Node (any type) and attach a new script to it:

```
# test_libreconomy.gd
extends Node

func _ready():
    print("=== Testing LibreEconomy ===")
    
    # Create a world
    var world = LibreWorld.new()
    print("LibreWorld created")
    
    # Test version
    var version = world.get_version()
    print("Library version: ", version)
    
    # Test agent creation with defaults
    var agent1 = world.create_agent()
    print("Created agent 1 (default): ", agent1)
    
    # Test agent creation with custom needs
    var agent2 = world.create_agent_with_needs(75.0, 25.0)
    print("Created agent 2 (thirst=75, hunger=25): ", agent2)
    
    # Test agent creation with wallet
    var agent3 = world.create_agent_with_wallet(500.0)
    print("Created agent 3 (currency=500): ", agent3)
    
    # Test agent creation with all parameters
    var agent4 = world.create_agent_full(90.0, 10.0, 1000.0)
    print("Created agent 4 (full params): ", agent4)
    
    # Check agent count
    var count = world.get_agent_count()
    print("Total agents: ", count)
    assert(count == 4, "Should have 4 agents")
    
    # Test agent removal
    world.remove_agent(agent2)
    count = world.get_agent_count()
    print("Agents after removal: ", count)
    assert(count == 3, "Should have 3 agents after removal")
    
    print("=== All tests passed! ===")
```


7. Run the Scene
Press F6 (or click "Run Current Scene") and check the Output panel. You should see:

```
=== Testing LibreEconomy ===
LibreWorld created
Library version: libreconomy 0.0.1
Created agent 1 (default): 0
Created agent 2 (thirst=75, hunger=25): 1
Created agent 3 (currency=500): 2
Created agent 4 (full params): 3
Total agents: 4
Agents after removal: 3
=== All tests passed! ===
```

8. Troubleshooting
If you see "LibreWorld is not a recognized class":

Make sure you restarted Godot after copying the files
Check that all three files are in addons/libreconomy/
Verify the .gdextension file has correct paths
If you see "Cannot load library" errors:

Check that both .so files are in the same directory
Verify you're running on Linux x86_64
Check file permissions: chmod +x addons/libreconomy/*.so
If you get runtime crashes:

Check the Godot console for error messages
Verify GODOT_CPP_DIR pointed to the correct godot-cpp build
Rebuild: bash scripts/release.sh
9. More Complex Test (Optional)
Create a more visual test by spawning Node2D objects for each agent:

```
extends Node2D

var world: LibreWorld
var agent_nodes = {}

func _ready():
    world = LibreWorld.new()
    print("Version: ", world.get_version())
    
    # Spawn 10 agents visually
    for i in range(10):
        var agent_id = world.create_agent()
        spawn_agent_visual(agent_id)
    
    print("Created ", world.get_agent_count(), " agents")

func spawn_agent_visual(agent_id: int):
    var sprite = Sprite2D.new()
    sprite.texture = preload("res://icon.svg")  # Use Godot's default icon
    sprite.position = Vector2(randf() * 800, randf() * 600)
    sprite.scale = Vector2(0.1, 0.1)
    add_child(sprite)
    agent_nodes[agent_id] = sprite

func _input(event):
    if event is InputEventMouseButton and event.pressed:
        # Remove a random agent on click
        if world.get_agent_count() > 0:
            var agent_ids = agent_nodes.keys()
            var random_id = agent_ids[randi() % agent_ids.size()]
            world.remove_agent(random_id)
            agent_nodes[random_id].queue_free()
            agent_nodes.erase(random_id)
            print("Removed agent ", random_id, ". Remaining: ", world.get_agent_count())
```

This creates visual representations of agents and lets you click to remove them.

That's it! You now have a working integration of libreconomy in your Godot project. The library is ready for you to build economic simulation features on top of.
